# Validate

> ## ðŸ›  Status: Pilot Phase
> Lion Web Components are still in an early alpha stage; they should not be considered production ready yet.
>
> The goal of our pilot phase is to gather feedback from a private group of users.
> Therefore, during this phase, we kindly ask you to:
> - not publicly promote or link us yet: (no tweets, blog posts or other forms of communication about Lion Web Components)
> - not publicly promote or link products derived from/based on Lion Web Components
>
> As soon as Pilot Phase ends we will let you know (feel free to subscribe to this issue https://github.com/ing-bank/lion/issues/1)

## Features

- allow for advanced UX scenarios by updating validation state on every value change
- provide a powerful way of writing validation via pure functions
- multiple validation types(error, warning, info, success)
- default validators
- custom validators

Validation is applied by default to all [form controls](https://github.com/ing-bank/lion/blob/master/packages/field/docs/FormFundaments.md) via the
ValidateMixin.

For a detailed description of the validation system and the `ValidateMixin`, please see [ValidationSystem](https://github.com/ing-bank/lion/blob/master/packages/validate/docs/ValidationSystem.md).

## How to use

### Installation

```sh
npm i --save @lion/validate
```

```js
import '@lion/input/lion-input.js';
import { %ValidatorName% } from '@lion/validate';
```

> Note that we import an lion-input here as an example of a form control implementing ValidateMixin.
> We could equally well use lion-textarea, lion-select, lion-fieldset etc. to illustrate our example.

### Example

All validators are provided as pure functions. They should be applied to the formcontrol (implementing
`ValidateMixin`) as follows:

```js
import '@lion/input/lion-input.js';
import { Required, IsString, MaxLength, DefaultSuccess, Validator } from '@lion/validate';

const isInitialsRegex = /^([A-Z]\.)+$/;
class IsInitialsExample extends Validator {
  static get validatorName() {
    return 'IsExampleInitials';
  }

  execute(value) {
    let hasFeedback = false;
    const isStringValidator = new IsString();
    if (!isStringValidator.execute(value) || !isInitialsRegex.test(value.toLowerCase())) {
      hasFeedback = true;
    }
    return hasFeedback;
  }

  static getMessage({ fieldName }) {
    return `Please enter a valid {fieldName} in the format "A.B.C.".`;
  }
}
```

```html
<lion-input
  label="Initials"
  name="initials"
  .validators="${[new Required(), new MaxLength(10), new IsInitialsExample(null, { type: 'warning' }), new DefaultSuccess()]}"
></lion-input>
```

In the example above we use different types of validators.
A validator applied to `.validators` expects an array with a function, a parameters object and
optionally an additional configuration object.

```js
MinMaxLength({ min: 5, max: 10 });
```

The custom `IsInitialsExample` checks if the value is fitting our regex, but does not prevent the user from submitting other values.

Retrieving validity states is as easy as checking for:

```js
myInitialsInput.hasFeedbackFor.include('error');
```
